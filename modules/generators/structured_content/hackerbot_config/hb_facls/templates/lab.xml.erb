<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'
  require 'erb'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first)
  $main_user = $first_account['username'].to_s
  $main_user_pass = $first_account['password'].to_s

  $second_account = JSON.parse(self.accounts[1])
  $second_user = $second_account['username'].to_s
  $second_password = $second_account['password'].to_s

  $third_account = JSON.parse(self.accounts[2])
  $third_user = $third_account['username'].to_s
  $third_password = $third_account['password'].to_s

  # $fourth_account = JSON.parse(self.accounts[3])
  # $fourth_user = $third_account['username'].to_s
  # $fourth_password = $third_account['password'].to_s

  $server_ip = self.server_ip.first
  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 2
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end

  def get_binding
    binding
  end
-%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
  <get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@{{chat_ip_address}} /bin/bash</get_shell>

	<messages>
		<show_attack_numbers />

		<greeting>Hi there. Solve some challenges and I'll give you some flags.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next one...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skipping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last one for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last one. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Doing my thing...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>...</got_shell>
		<got_shell>....</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on say 'next', or 'previous' and I'll move things along.</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is *X*".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>Access Controls: ACLs</title>
		<tutorial><%= ERB.new(File.read self.templates_path + 'intro.md.erb').result(self.get_binding) %></tutorial>
		<footer>
<%= File.read self.templates_path + 'resources.md.erb' %>

<%= File.read self.templates_path + 'license.md.erb' %>

Randomised instance generated by [SecGen](http://github.com/cliffe/SecGen) (<%= Time.new.to_s %>)
		</footer>

		<provide_tutorial>true</provide_tutorial>

	</tutorial_info>

  <attack>
    <% $rand_secret4 = "secret#{SecureRandom.hex(3)}" %>
    <% $rand_secret_file4 = "/home/#{$main_user}/secret#{SecureRandom.hex(3)}" %>
		<prompt>On your desktop system, create a file, <%= $rand_secret_file4 %>, containing the string <%= $rand_secret4 %>. Make sure the file is owned by <%= $main_user %>. Use Linux ACLs (without using groups) to enable <%= $second_user %> to also read the file, but not write to it. Make sure <%= $third_user %> can't access the file.</prompt>

    <!-- <get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@<%= $server_ip %> /bin/bash</get_shell> -->

    <post_command>sudo -u <%= $main_user %> grep <%= $rand_secret4 %> <%= $rand_secret_file4 %> >/dev/null; echo m-$?-; sudo -u <%= $second_user %> grep <%= $rand_secret4 %> <%= $rand_secret_file4 %> >/dev/null; echo s-$?-; sudo -u <%= $third_user %> grep <%= $rand_secret4 %> <%= $rand_secret_file4 %> >/dev/null; echo t-$?-; sudo -u <%= $third_user %> bash -c 'echo "hackerbot/<%= $third_user %> was here!" > <%= $rand_secret_file4 %>' >/dev/null; echo tw-$?-; ls -l <%= $rand_secret_file4 %> | grep +; echo f-$?- ; getfacl <%= $rand_secret_file4 %> | grep '^group:[^:]'; echo g-$?- </post_command>

    <condition>
			<output_matches>No such file or directory</output_matches>
      <message>:( It looks like the file might not exist.</message>
		</condition>
    <condition>
			<output_matches>m-0-.*s-0-.*t-2-.*f-0-.*g-1-</output_matches>
      <message>:) Well done! <%= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
    <condition>
			<output_matches>m-0-.*s-0-.*t-2-.*f-1-</output_matches>
      <message>:P Looks like you got all the file access working, but you are supposed to use facls without groups for this task!</message>
		</condition>
    <condition>
			<output_matches>tw-0-</output_matches>
      <message>:( Your file wasn't protected from <%= $third_user %>!</message>
		</condition>
    <condition>
			<output_matches>t-0-</output_matches>
      <message>:( Looks like <%= $third_user %> can read the file... Use groups and set permissions to make sure they can't do so...</message>
		</condition>
    <condition>
			<output_matches>m-0-.*s-0-</output_matches>
      <message>:( Looks like <%= $main_user %> and <%= $second_user %> can access the file... Almost there. Make sure <%= $third_user %> doesn't have permission to access it.</message>
		</condition>
    <condition>
			<output_matches>s-0-</output_matches>
      <message>:( Looks like <%= $second_user %> can access the file... Almost there...</message>
		</condition>
    <condition>
			<output_matches>s-2-</output_matches>
      <message>:( Looks like <%= $second_user %> can't access the file... Use ACLs to make sure they can...</message>
		</condition>
    <condition>
			<output_matches>m-0-</output_matches>
      <message>:( Looks like <%= $main_user %> can access the file... Almost there...</message>
		</condition>
    <condition>
			<output_matches>m-1-|s-1-</output_matches>
      <message>:( Looks like the file has the wrong contents...</message>
		</condition>
    <else_condition>
      <message>:( Something was not right</message>
		</else_condition>

	</attack>


  <attack>
    <% $rand_shared_dir = "/home/#{$main_user}/shared#{SecureRandom.hex(3)}/" %>
		<prompt>On your desktop system, create a directory, <%= $rand_shared_dir %>. Make sure the directory is owned by <%= $main_user %>. Use Linux ACLs (and Unix special permissions, but not groups) to enable <%= $second_user %> and <%= $third_user %> to also create shared files in the directory (read and write for all three users), but not delete files owned by each other.</prompt>

<!-- TODO!!!!!! -->
    <post_command>sudo -u <%= $main_user %> bash -c 'echo "<%= $main_user %> was here!" > <%= $rand_shared_dir %>/shared_file' >/dev/null; echo m-$?-; sudo -u <%= $second_user %> bash -c 'echo "<%= $second_user %> was here!" >> <%= $rand_shared_dir %>/shared_file' >/dev/null; echo s-$?-; sudo -u <%= $third_user %> bash -c 'echo "<%= $third_user %> was here!" >> <%= $rand_shared_dir %>/shared_file' >/dev/null; echo t-$?-; ls -l <%= $rand_shared_dir %>/shared_file | grep +; echo f-$?- ; getfacl <%= $rand_shared_dir %>/shared_file | grep '^group:[^:]'; echo g-$?-; sudo -u <%= $second_user %> rm <%= $rand_shared_dir %>/shared_file >/dev/null; echo del-$?-;  </post_command>

    <condition>
			<output_matches>No such file or directory</output_matches>
      <message>:( It looks like the directory might not exist (or perhaps a permissions issue).</message>
		</condition>
    <condition>
			<output_matches>m-0-.*s-0-.*t-0-.*f-0-.*g-1-.*del-1-</output_matches>
      <message>:) Well done! <%= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
    <condition>
			<output_matches>m-0-.*s-0-.*t-0-.*f-1-</output_matches>
      <message>:P Looks like you got all the file access working, but you are supposed to use facls for this task! Hint: Make sure you have set a default ACL.</message>
		</condition>
    <condition>
			<output_matches>del-0-</output_matches>
      <message>:( A file created by <%= $main_user %> wasn't protected from being deleted by <%= $second_user %>! Hint: consider using the sticky bit.</message>
		</condition>
    <else_condition>
      <message>:( Something was not right. Make sure all three users can access the file. </message>
		</else_condition>

	</attack>



	<attack>

		<prompt>There is a file permissions problem on the server, which could enable normal users to read any files. There is a flag to be found in a home directory. This is the end.</prompt>

		<condition>
			<output_matches>.*</output_matches>
			<message>:)</message>
			<trigger_next_attack />
		</condition>
    <condition>
			<output_matches>.*</output_matches>
			<message>:)</message>
			<trigger_next_attack />
		</condition>
		<else_condition>
			<message>:)</message>
		</else_condition>

	</attack>

<!-- TODO: add another attack where HB uses a hardlink attack against the SUID program - they have to fix the problem  -->

</hackerbot>
